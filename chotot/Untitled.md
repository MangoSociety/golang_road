Введение

0:00

Привет скорее всего тебе уже надоели примитивный мог собеседование по гору где спрашивают только лишь о слайсах

0:05

либо матах поэтому я сегодня позвал старшего разработчика из Тиньков где вместе с ним мы проведём мох

0:11

собеседование по канкарэнси в гоу будем говорить о том как устроены бьютексы под капотом Как работает грудины планировщик

0:18

Go и так далее Поехали Так Денис привет Сегодня у нас мог собеседование по кон

Горутины под капотом

0:23

Карен гоу ты готов Привет Конечно давай начнем наверное с самого такого

0:30

насущного что такое рутина

0:36

это такой аналог наверное стоит рассказать Чем отличается

0:42

от темного потока в первую очередь классический ответ легковесность крути

0:49

на МГУ выполняется самим языком

0:54

у них динамичный он может как расти так и сужаться

1:00

отличать потоков они требуют гораздо меньше оперативной памяти для инициализации

1:06

8 мегабайт что такое примерно 8 я встречал

1:14

да да меньше в этом районе Наверное это самое

1:20

Ключевое подробнее поспрашивает то что ты назвал ты сказал рутины Какие виды

1:26

картины и какие угол Вот тут я затрудняюсь ответить честно говоря так глубоко мне

1:32

стык лес либо стеклутина не слышу Окей хорошо тогда ты рассказал про расширение

Расширение стэка горутины

1:39

стека можно подробнее рассказать как он стек расширяется там какая вообще алгоритм расширения И так далее

1:46

он слушай все что я помню что какое-то время там был стейк который основан на

1:51

сегментах и там то есть сегмент когда он заполняется новый сейчас по моему он

1:59

просто растет таких сегментов нет но опять же подробности они То есть раньше получается был сегмент италья как

2:04

связанный список нужен А в чем проблема была сегменте Почему от него ушли как думаешь

2:14

не знаю не знаю тоже сложно вызвал функцию вернулся вызвал функцию

2:20

вернулся у тебя получается вот это последний верхушка стояка делается

2:26

сейчас получается просто мы копируемся

Разница потоков и горутин

2:37

потоков и рутин то есть гарантин получается работает

2:43

подробнее Почему они медленные Почему из-за Чего это медленно все происходит

2:51

там на самом деле много проблем во-первых в целом потоки это именно сущность операционной системы и там

2:58

много своих особенностей но в частности поток вынужден хранить состояние регистров правильно при переключении это

3:04

тоже влияет императивную память переключения опять же переключение контекста там тоже

3:12

занимает дольше чем Приключение контекста рутины но причинах Я не собираюсь глубоко тоже не копал

3:20

главное разница Кооперативный

3:26

текущий 13 по моему 1413 А синхронний

3:37

английский он уже не Кооперативный А какой

3:43

там частично насколько я знаю когда я изучал ты давно уже тоже не погружался он был именно Кооперативный Сама решает

3:50

когда отдать на планировщике мы чуть побольше дойдем

3:55

Вот ты затронул тему контекста потока то есть потока есть получается регистратор

4:01

то есть его стоит Где хранить А что у потока еще есть какой у него стоит есть

4:06

Я подозреваю что там там же хранятся например дискрипторы

4:11

открытых файлов например ну я тут не помню

4:21

так сразу [музыка]

4:30

какой у нее контекст так мы уже сказали что динамические

4:36

растет а соответственно регистры они общины все программы получаются если

4:42

будет происходить То есть просто допустим у меня есть какой-то указательств и какой-то для

4:51

каждой получается программки нужно тоже контекст да Все правильно Нужно тоже хранить

Context switching

5:03

системные тонкости но просто порассуждаем Почему может медленно происходить просто по накидом вариант

5:09

Почему контекст вичен потоков медленный

5:15

тоже интересный вопрос на самом деле

5:22

мы сказали уже про регистры Да что их нужно каким-то образом где-то сохранять скачать

5:28

по-моему Я боюсь ошибиться по моему они тоже регистрировать вроде бы Если не

5:35

ошибаюсь вот еще что есть есть или нет пока что

5:40

нет виртуальной памяти что может быть там какие-то таблицы там виртуальной

5:47

памяти есть тоже нужно сохранять

5:53

то есть вымывается

6:01

гарантинах они тоже могут вымываться и так далее и так далее и так далее но и много разных

6:07

Хорошо давай тогда ты затронул планировщик

Планировщик в Go под капотом

6:13

Ну глобально там какая идея вот у нас есть какое-то количество груди у нас есть какое-то количество системных

6:20

трудов и есть такая абстракция которая называется по-моему процессор соответственно процессор хранит себе

6:26

локальную очередь и каждому процессору привязан тренд почему же это абстракция Ну потому что

6:34

трудов не постоянно количество какой-то их количество может увеличиваться Вот

6:40

например если какая-то грудина заблокировалась на системном вызове Если

6:45

не ошибаюсь таком случае новый тренд текущий процесс привязывается

6:50

картинка блокируется происходит

Системные вызовы с горутинами

6:58

то есть хорошо мы отцепили от процессора Трейд за грудинкой и он это что-то

7:03

выполнился да то есть мы поток перешел который выполнял процесс ядра выполнился

7:08

скол вернулся пользовательский режим что происходит Дальше Куда идет поток и куда возвращается грудинка

7:14

кладется в какую-то некую глобальную очередь и потом картинки из нее раз какой-то

7:24

выполнение но поток Я подозреваю

7:29

бессмысленно было бы тратить Всегда ли это так работает есть какие-то

7:36

нюансы когда это не так работает С какими-то

7:42

Ну наверное Если речь идет про сетевые вызовы да то есть вызовы там работают

7:47

асинхронно да там используется конструкция как называется мультиплексор который

8:01

асинхронным есть какая-то абстракция поля То есть как раз абстрактно то есть

8:08

сетевой падает туда и сразу же всех вообще которые программы

8:14

делаются и картина тоже попадает паркуется именно в это место получается

8:19

супер можешь рассказать про workshering И workstering что это такое

Work sharing и work stealing

8:26

Я знаю что хотя не уверен что ринг может быть уже есть когда я читал про это

8:35

появилось идея простая если процессора не осталось

8:43

Никакой работы то он идет по другим процессором и забирает часть

8:49

Давай просто вот и почему не сделать

8:59

Ну видимо чтобы это хорошо масштабировалось если будет какая-то глобальная очередь то нужно будет

9:05

повесить видимо чтобы супер супер да Окей хорошо а вот мы

9:12

немного ПРО модель многозадачности Да оперативно вытесняешься можешь подробнее

Кооперативная и вытесняющая многозадачнось

9:18

рассказать концептуальное различие кооперативные вытесняешься Ну на мой взгляд Ключевая разница такая

9:25

что если там грудины или поток выполняется и сама рутина подсказывает

9:31

когда ее можно вытеснить контекст Да и начать другую грудью вытесняющий средства он сам

9:39

прерывает потоки или рутины и сам управляет когда кого снимать

9:44

такой планировщик Кооперативный говорит что уже немножко другой чуть-чуть другой

9:51

да да Вот смотри если мы говорим про планировщик операционной системы А какие алгоритмы планирования знаешь или давай

Алгоритмы планирования

9:57

если ты не знаешь просто попытаемся придумать как можно планировать потоки

10:02

То есть у меня есть пул каких-то задач Я не знаю сидят им нужно выполнить задачу

10:07

как планировать как выставлять кому-то задача попытаемся Да да все что все что

10:13

глобально знаю что там выбирается какой-то некий квант времени он делится между всеми потоками и плюс там еще есть

10:21

какая-то приватизация то есть каких-то потоков есть приоритет над другими которые нужно которые получают больше

10:26

времени приоритетное планирование да А давай подумаем еще может какие-то алгоритмы

10:32

подумаем посмотрим придумаем так сказать приоритетная есть

10:40

конкретных проблем я так сходу не могу

10:45

такая Задачка Вот у тебя есть 4 программиста сидят за столами и те

10:50

постоянно приходят задачи от бизнеса эти нужны им распределить как-то задачи и каждая задача занимает разные промежуток

10:56

времени как тебе нужно планировать Ну вот Представь что ты планировщики операционной системы подумаем можно

11:03

использовать можно С простых самых простых начать не обязательно просто просто раунд Робертом

11:14

Ну а затем следующая задача твовать первому освободившемуся в любом случае это работает не так просто мне кажется

11:20

может такая проблема что какая-то программа заняла одному разработчику нашего условного Да я бесконечно

11:26

выполняется и не дает другим программам работать как раз Именно поэтому используется квант времени чтобы далеко

11:32

не программе поработать снимаем места следующее ты примерно все писал тоже есть популярный алгоритмы шорт форста то

11:39

есть самая маленькая работа первое что по-быстрому есть еще там типа очередь в принципе то

11:46

что ты писал Окей Хорошо давай поговорим с тобой синхронизации мы

Примитивы синхронизации

11:51

поговорим Какие примитивными синхронизации пользовался может быть не только в голову вообще в целом лучше

12:01

каналы а томики остальные уже не такие примитивы группы там что еще есть

12:15

Ну вы группа Конечно если канал даже канал

Мьютексы под капотом

12:23

Как бьют иксы устроены как вот есть понимание нет или если нет Давай

12:28

попробуем предположить если говорить глобально Я подозреваю что я прям кишки не залазил Кошки да Но

12:35

обычно наверное там просто какой-то условный Казан а Томик операция на

12:40

уровне железа есть которая позволяет сравнить и получить сразу результат удалось или нет

12:48

Наверное он там уже как-то посложнее устроен Наверное нужно как-то хранить количество

12:53

читателей условных там какой-нибудь и как-то когда мы берем должны дождаться

12:59

когда количество читателей пойдет до нуля чтобы захватить индекс то есть посложнее обычный

13:06

обсудим базовый Ну ты правильно сказал флажок какой-то спину

13:12

Плохо работал у нас был цикл актив ного ожидания но без цикла активного ожидания

13:17

а как когда стрелок работает без цикла ожидания Ну конкретно Я думаю что как раз грудины

13:26

которая питается выполнение ставится очередь

13:46

Мне кажется да вроде бы А если я могу сделать

13:52

Unlock не залоченного мьютекса а я кстати не знаю что здесь таком

13:57

случае произойдет какой кейс вот допустим когда мютекс залочил Если я

14:03

пойду с другой грудинки залочу я встану за паркуюсь А если с той же самой сделаю Лог дважды У меня паника будет то есть

14:10

мне еще нужно трекать яичник картинки которые заблоки ровала то есть хорошая особенность получается нужен античный грудинки и

14:18

нужен флажок Окей и просто говорю что я снимаюсь с исполнении став меня выйти на

14:24

грубо говоря мы говорим про спин Локи кейсы Когда можно использовать что вообще такое станок можешь описать

Spinlock

14:31

когда просто по сути насколько я понимаю Весь процесс

14:40

не знаю вообще стоит имеет смысл использовать

14:46

не знаю Ну когда допустим перед вызовываем явно понимаем не будет никаких сосков не будет никаких длительных операций там в какую-то

14:53

критической секции нужно сделать минимум и может иногда просто проще взять этот

14:59

пару раз прокрутиться в каслупе нежели чем снимать гарантингу или какой-то потом Окей хорошо Давай поговорим о проблемах

Deadlock, livelock, data race

15:07

организации

15:15

участок памяти он разделяется между потоками Да и одновременно как-то изменяется соответственно Нужны как раз

15:21

примите вы синхронизации канала прочее вот эта ситуация когда все грудины

15:27

одновременно заблокированы Никакая из них не может продолжить свою работу в таком случае называется паника

15:35

достаточно редкая штука честно говоря особо не разбирался не читал и

15:42

хорошо давай подумаем поговорим про блок представим такую взаимоисключающий Блок

15:49

Когда у меня то есть она взяла одну другая другую как исключить ситуацию

15:55

когда у меня есть так Ну первое что приходит в голову

16:03

сделать так чтобы всегда был одинаковый порядок естественно оборот

16:14

Ну да это уже там детали какие-то самое основное порядок просто порядке а

16:22

мы поговорили про канал давай Ну если ошибаюсь Там просто две очереди

Каналы под капотом

16:30

кольцевые типа на ресив на стенд соответственно когда

16:36

там кольцевой просто да кольцевой буфер Да и

16:42

соответственно приходит какое-то значение если канал не буферизированный то

16:49

добавляется Если ошибаюсь просто снимается

16:56

читателей

17:02

есть очередь

17:09

Давай обсудим Какой канал быстрее буферизированный

17:18

Да мне кажется что они должны работать там примерно одинаково потому что там есть

17:24

особенность если ты кладешь у тебя ждет какой-то читатель грудинка какая-то То

17:30

есть сразу можешь значение в You Stack и это все будет копироваться без промежуточных узлов без каких-то буферов

17:36

ты сразу складываешь А ну да небо переселена канала чуть быстрее

17:42

Хорошо давай пойдем дальше и Давай мы с тобой

17:47

поговорим что мне тут дальше по плану что происходит когда канал заполнен

17:53

то есть поподробнее вот канал запомнился канал на 10 элементов и приходит еще одна ставка

18:00

Ну соответственно блокируется снимается

18:10

соответственно когда приходит Читающий грунтина забирает этот элемент и заблокирует

18:16

предыдущую рутину стоит

18:23

так А если просто потом буфер попадет они работают

Семафоры

18:32

Ну да да в год обычно делают как раз помощью бифизированного канала то есть способы ограничить количество

18:37

одновременно Следующий вопрос Как реализовать

18:43

вот Окей мы говорили проказ что такое кас

Compare and swap (CAS)

18:48

Ну то есть campire slop это атомарная операция на уровне железа процессора и так далее которые позволяют

18:55

название сравнить то есть ты можешь

19:00

да это может сравнить вы сразу заменить получить результат точно такой же

19:07

Слушай а вот здесь хотел спросить какие проблемы возникать не сталкивался никогда

19:14

Я на практике точно не сталкивался не знаю

19:24

теперь поговорим про текст

Контексты под капотом в Go

19:31

просто просто интерфейс которого там есть методы возвращает канал

19:36

соответственно как только контекст завершается работу канала приходит он скрывается

19:47

контекст значениями

19:52

контекстов самые простые

19:58

одинаково это просто по сути пустая структура и методы ничего не делает канал никогда ничего не будет записано поэтому они подходят для

20:05

Ну просто каких-то фоновых жоп есть соответственно контекст отмены который просто

20:12

возвращает функцию cancel как ты вызываешь Когда происходит вызов кэнселла что

20:20

происходит как вообще грудинки понимает что контекст отменился мы просто закрываем канал И все кто

20:27

слушает этот канал Они получают таким образом сообщение Мы хотим написать контекст как его

20:36

сделаем просто Безумный интерфейс и все методы

20:42

доставляем пустыми и возвращаем пустой канал который согласен но я имею ввиду consolation то

20:49

есть тайм-ауте происходит отмена контекста через какое-то время Вот как это реализовать А ты говоришь

20:56

соответственно запускаем какой-то тикер отдельный грудинки который через какое-то определенное время запишет

21:03

сразу все получили сообщение потому что ресурсы Нужно почистить если

21:12

контекст завершился

21:22

Я думаю что это сработает нормально то есть мы возле конца закрыли эту картинку А дальше ничего не происходит Просто То

21:28

есть она же может Внутри там внутри рутинки по консилится еще обычно пишет defer повторно конце лица

21:34

хорошо А давай тогда мы немного окунемся в архитектуру компьютера поговорим про

21:41

параллельность там вот как процесса как процессора Значит ты может параллерить

Параллельное выполнение кода на одном ядре

21:47

выполнение команд на одном ядре то есть ну мы знаем что можно поставить несколько ядер на стал да и Окей мы

21:56

будем иметь несколько физических но как можно проверить выполнение команд на дом

22:03

прямо параллели чтобы физически одновременно выполнялись Да честно говоря не знаю глубоко тоже не

22:08

погружался там есть какие-то логически что ли ядром как они работают честно говоря они конвейер не слышал

22:15

а не слышал про векторизацию команд То есть это псевдоподобление

22:22

сталкивался никогда тоже да да назвал логические ядра скорее всего

22:29

гипертерьер тренинг правильно понимаю что типа того да и опять же погружался поэтому

22:35

не расскажешь просто да если глубоко не больше тогда

22:42

не будем спрашивать последние вопросы хотелось спросить по поводу кэшей вот смотри представим что у меня есть 4 ядра

Когерентность кэшей

22:47

2 ядра возьмем есть память оперативная и между памятью и ядрами но есть крыши

22:53

давай возьмем какой-нибудь один уровень Будем рассматривать что у нас один уровень и представим что поток

23:00

высчитывают из памяти какое-то значение в кэш и второй там получается не значение это ядро

23:07

меняет допустим тройку на пятерку а это ядро меняет тройку на четверку как я

23:13

буду синхронизировать эти когда записывать не знаешь как приблизительно это все работает

23:18

Да ну вообще уровень жизни предполагаю что просто в первую очередь

23:23

записывается значение в кэш потом уже оперативную память Ну может быть это profold shading никогда не слышал не

23:29

сталкивался Нет Нет за счёт синхронизации есть популярный там протокол Месси там ну вместе более такое

23:35

обучающий есть более трудное и Как раз-таки насчёт того что потоки друг другу мешают Ну ядра пишет И как бы

23:42

полчаренный Происходит что ядра начинают друг друга мешать и Казалось бы использовать быстрее они всегда так

23:49

получается О'кей А давай в конце ещё Прощаемся задачки такие знаешь больше

Синхронизация map

23:54

теоретические вот Представь у нас есть задача есть Маков Мы хотим есть

24:04

Да ну классический способ это просто использовать соответственно чтение на все

24:11

запись обычный блог используем чтением используем

24:16

будет работать когда у нас много читателей писателей

24:27

сказали чтобы было мало вот этих блокировками представим что у нас много гарантин берут и паркуются при входе в

24:34

этот можно решить

24:41

Вот почему планировщики сделали локальные очереди Ты сказал ну чтобы не было какого-то очереди куда будут все

24:47

потоки спотыкаться в него Да и представим что у тебя на какой-то runtime у тебя там десятки гарутин и они

24:53

постоянно в Real Time работают с мамой то есть много обращений и не постоянно мешают друг друга Ну спотыкаются набью

24:59

такси блокируется там Ну первое что приходит в голову наверное как-то шарнировать разделить на

25:05

несколько типа и по какому-то ключу то есть матка пошагировать каждый будет супер А еще посмотреть

25:14

Что еще можно сделать опять же тебе рассказал

25:22

что еще сразу больше ничего не приходит понятно Делает последнюю очередь потому

25:28

что особенно слабый но тем не менее тоже принципе можно

25:34

Окей Хорошо давай еще одна задача есть задача связаны с суп-сервером

Архитектура web сервера

25:40

Давай посмотрим такую задачу что мы хотим написать веб-сервер на какой-нибудь Апач или Джинс например и

25:47

Давай обсудим архитектуру как мы будем писать точки зрения Понятное дело что нам нужно обрабатывать там десятки сотни

25:53

тысяч запросов Да архитектурные Какие подходом будем использовать для этого Давай вообще Обсудим все варианты просто будем

25:59

накидывать будем обсуждать их из того что я знаю там по сути есть два варианта два патче просто на каждый

26:05

запрос поднимается отдельный системный поток тренда и раз работает с помощью гипола который

26:12

немножко затронули с помощью асинхронных запросов то есть глобально там

26:19

получается такой же цикл как например там который клуб который лежит например

26:28

новые события да И когда мы делаем Это запросом кладется

26:34

супер вообще самого такого простого и самого устаревшего как чуть-чуть работает Можем

26:43

ли мы Под каждый создавать отдельный процесс Ну то есть физически это можно делать

26:49

Просто очень эффективно потому что во-первых процесс операционной системы и поэтому уже

26:56

говорили

27:02

мы можем запускать отдельный процесс

27:10

Ну во-первых потоки они все-таки шарят Одну одну память получается то есть для

27:17

процессора банально завести еще на адресное пространство поработать виртуальной

27:23

ресурсы так сказать то что сказал файловый дискрипторы там какие-то тоже

27:28

банально дольше Окей то есть Ладно процесс мы отметаем обсудим синхронный

27:33

подход то есть потоки вот представим себе разработчиками мы такие говорим что

27:38

хотим картинками все сделать там чтобы через и полы Все было круто нам говорят нет у нас идеологические синхронный

27:44

сервер поточный Под каждый как бы делать

27:51

Ну то есть любом случае количество потоков наверное стоит как-то ограничить Да чтобы не росли наверное один главный

27:59

поток который будет соответственно слушать новые соединения только приходит новое соединение будет брать

28:05

ему выполнение чтобы он обрабатывал соединение

28:12

и погнали например А вот почему вообще ну синхронно серый кажется такой не

28:19

особо вообще иди магический почему это не особо как думаешь

28:24

глобально потому что вообще все веб-сервис это именно iobound Задача В

28:30

основном у нас аю операции и там то есть потоки предназначены для именно для реализма чтобы обрабатывать много

28:36

операций параллельно А в двери обычно у нас теперь операции мало больше не

28:42

найдем не очень хорошо подходит да Супер Супер да точно переключились

28:48

там пошли другой поделали и так далее и последний подход как ты сказал у нас будут и пол и там Аля картинки какие-то

29:02

сервис именно Конечно синхронностью такой как используется других языках Хорошо давай тогда

Синхронизация связного списка

29:10

последнюю задачку возьмем Как можно синхронизировать

29:21

синхронизировать операции [музыка]

29:34

но опять же приходит в голову конечно использовать мьютукс Да хотя я думаю просто если у

29:40

нас связанный список и мы добавляем в конец по сути нам нужно за локоть именно последний элемент например с удаления

29:47

середины ее можно не локоть поэтому видимо смотреть мы можем дропнуть как

29:52

это элемент или добавить и ты давай такой старый пример когда мы добавляем какой-то элемент мы

30:00

должны получать залочить для соседних нот левую правую допустим добавляем

30:05

между ними остальные При этом могут как-то модифицироваться поэтому видимо удаление

30:15

то же самое

30:23

следующий элемент берем этот элемент у левой ноты

30:31

это предыдущее предыдущее перед удаляемый

30:37

А если может следующая вставить еще при удалении тоже нужно

30:50

какие-то вопросы было очень интересно Много сложных вопросов есть

Русский (создано автоматически)

Все видеоАвтор: Владимир БалунПохожий контентДля васНедавно опубликованныеПросмотрено

## 

Shorts

[![](https://i.ytimg.com/vi/KwUcMfr8Puo/oardefault.jpg?sqp=-oaymwEdCJUDENAFSFWQAgHyq4qpAwwIARUAAIhCcAHAAQY=&rs=AOn4CLAHJdL6CLqMXosQY5ocvy6x7OVL3Q)

](https://www.youtube.com/shorts/KwUcMfr8Puo)

### [Полезны ли курсы по программированию #айти #программирование #программист](https://www.youtube.com/shorts/KwUcMfr8Puo "Полезны ли курсы по программированию #айти #программирование #программист")

4,9 тыс. просмотров

[![](https://i.ytimg.com/vi/T5sPizaQ898/oardefault.jpg?sqp=-oaymwEdCJUDENAFSFWQAgHyq4qpAwwIARUAAIhCcAHAAQY=&rs=AOn4CLA4Abn9djbylXOymSi76j9wfQDntw)

](https://www.youtube.com/shorts/T5sPizaQ898)

### [Изучение новой парадигмы программирования #айти #программирование #программист](https://www.youtube.com/shorts/T5sPizaQ898 "Изучение новой парадигмы программирования #айти #программирование #программист")

6,5 тыс. просмотров

[![](https://i.ytimg.com/vi/nA03zGUxDIs/oar2.jpg?sqp=-oaymwEdCJUDENAFSFWQAgHyq4qpAwwIARUAAIhCcAHAAQY=&rs=AOn4CLCF5c2hwJShdOi_Jb4Ej8lMSPTy9Q)](https://www.youtube.com/shorts/nA03zGUxDIs)